C++ is a strongly-typed language.

/// ---

This means that this

---

struct Number { /* ... */ };

Number sum(Number lhs, Number rhs);

int main() {
	sum(Number{42}, Number{42}};
}

---

will compile and this

---

struct Number { /* ... */ };
struct String { /* ... */ };

Number sum(Number lhs, Number rhs);

int main() {
	sum(String{"forty two"}, Number{42}};
}

---

won't (assuming that there's no implicit conversion between Number and String).

/// ---

Type-safety is mostly enforced at compile-time which means it's:
* free (when it comes to run-time performance),
* always checked (there's no danger that an exotic, unchecked line of code be suddenly invalid at your E3 presentation).

/// ---

Good user-defined types have the added benefit of being descriptive and self-documenting. Consider the following examples:

* std::cos(3.0f) - what is 3.0f? By convention std uses radians everywhere, so it's a good guess.

* math::Cos(3.0f) - here we're using some external library.

We may be lucky that the parameter name suggests whether it's in degrees or radians.

float Cos(float angle_deg);

	Or maybe there's a comment.
	
// Calculates the cosine of the provided angle in degrees.
float Cos(float angle);

	Or maybe this library has it's own convention, which means you have to make sure it's followed and known by all programmers.
	Either way it's hard to tell by just reading the code what math::Cos(3.0f) means.

/// ---

Let's see what we can do about it.

// *************************************************************************

Type-rich programming - a super simple case.

Let's stay with the problem of angles. We can create a class Angle that internally keeps angles in radians

---

class Angle {
	...
private:
	float radians_;
};

---

and requires that whenever it is instantiated from a floating-point value a tag must be provided mentioning the unit.

---

struct RadiansTag {};
const auto radiansTag = RadiansTag{};

struct DegreesTag {};
const auto degreesTag = DegreesTag{};

class Angle {
public:

	Angle(RadiansTag, float r) : radians_(r) {}
	Angle(DegreesTag, float d) : radians_((PI / 180.0f) * d) {}
	
...
	
---

Retrieval of a floating point value must also specify whether the user wants degrees or radians.

...

class Angle {
public:
...
	float degrees() const {
		return radians_ * (180.0f / PI);
	}

	float radians() const {
		return radians_;
	}
...

/// ---

At this point the user code would look like this:

---

float cos(Angle a); // a function taking an angle as a parameter
Angle acos(float c); // a function returning an angle

int main() {
	const auto c = cos(Angle(degreesTag, 45.0f));
	const auto a = acos(c);
	std::cerr << c.radians() << " rad"; // will print "0.785 radians" (approximately)
}

---

There is no way to make an error in initialisation or retrieval of the angle value. The functions use types that clearly define what the values represent.

/// ---

C++11 gave us user-defined literals, so we can make initialisation even nicer

---

Angle operator""_deg(long double d) {
    return Angle{degreesTag, static_cast<float>(d)};
}

Angle operator""_deg(unsigned long long d) {
    return Angle{degreesTag, static_cast<float>(d)};
}

Angle operator""_rad(long double r) {
    return Angle{radiansTag, static_cast<float>(r)};
}

Angle operator""_rad(unsigned long long r) {
    return Angle{radiansTag, static_cast<float>(r)};
}

---

This allows us to replace

---

const auto c = cos(Angle(degreesTag, 45.0f));

---

with

---

const auto c = cos(45_deg);

---

/// ---

Furthermore we can:
* make sure only those arithmetic operations that make sense may be performed (e.g. provide addition and subtraction of angles, but no multiplication or division; multiplication by scalar but no scalar-value addition)
* provide comparison functions that take into account floating-point value rounding errors
* make everything constexpr!

/// ---

SHOW FINAL VERSION OF Angle.hpp, tests and benchmarks, run them, show generated assembly which is identical for floats and Angle (with exception of user-defined literals for VC++), show results of how this affects compilation times.

// *************************************************************************

Now we have a pretty neat implementation of an Angle class. There are however many other dimensions (distance, mass, time), which could be raised to a power (distance^2 => area) and should work with each other yielding even more complicated types (distance / time^2 => acceleration). Writing all this code would mean a lot of typing and duplicated code. Thankfully we have templates to the rescue.

I'm going to show you an implementation inspired by a class proposed by Biarne Stroustrup in an article (LINK TO ARTICLE). There is an even more ambitious implementation in Boost, that allows the creation of multiple sets of unit types, but this is perhaps overkill (LINK TO BOOST LIB).

We're going to limit ourselves to three dimensions: distance, mass and time. Adding more is pretty straightforward and probably unnecessary.

/// ---

We'll need a class that will represent a value in a given unit. Because we want to handle many different unit types this will have to be a template:

---

template <class Unit>
class Value {
public:

	explicit Value(float value) : value_(std::move(value)) {}
	
private:
	
	float value_;

};

---

The fact that the constructor is explicit means that the user needs to specify the wanted unit type when going from literal to value type. We'll want to have implicit conversion between values of units representing the same dimension, e.g. we'll want a function taking a speed parameter in km/h to accept values in m/s (but not others). Our "Unit" type will therefore have to be able to tell whether one unit type is convertible to another and provide a conversion ratio. We will definitely also need a function that returns the actual floating point value encapsulated. We'll force the player to provide a unit they want the value in. This checks for possible errors that can occur when using templates, auto or automatic refactoring.

---

template <class Unit>
class Value {
	...
	
	template <CompatibleUnit>
	Value(Value<CompatibleUnit> compatibleValue) : value_(compatibleValue.value<Unit>()) {}
	
	template <CompatibleUnit>
	float value() {
		static_assert(Unit::IS_CONVERTIBLE_TO<CompatibleUnit>);
		using Ratio = Unit::ConversionRatio<CompatibleUnit>;
		if constexpr (std::ratio_equal_v<Ratio, std::ratio<1, 1>>) {
			return value_;
		} else {
			return (static_cast<float>(Ratio::num) / static_cast<float>(Ratio::den)) * value_;
		}
	}

	...
};

---

Addition, subtraction and comparison can now be defined in terms of the value function and allowed for all compatible value types

---

template <class Unit>
class Value {
	...
	
	template <class CompatibleUnitT>
	constexpr Value& operator+=(Value<CompatibleUnitT> other) {
		value_ += other.value<Unit>();
		return *this;
	}

	...
};

---

Multiplication and division on the other hand can be performed using any value types, but requires more from the yet undiscussed Unit type

---

template <class Unit>
class Value {
	...
	
	template <class OtherUnit>
	friend constexpr auto operator*(Value lhs, Value<OtherUnit> rhs) {
		using UnitProduct = decltype(decltype(lhs)::Unit{} * decltype(rhs)::Unit{});
		return Value<UnitProduct>{lhs.value_ * rhs.value<OtherUnit>()};
	}

	...
};

/// ---

Now that we have the requirements for the unit type, let's figure out how to define it. We want types for different units to be different (so distance will have a different type than acceleration), but also to differentiate between different flavours (so separate km/h from m/s).

---

template <
	class TO_M_RATIO, int M_EXP,
	class TO_KG_RATIO, int KG_EXP,
	class TO_S_RATIO, int S_EXP
>
class Unit;

---

The class parameters are instances of the std::ratio template, which is a compile-time representation of rational numbers. The _EXP parameters are exponents for each dimension. Let's define a few aliases:

---

using Metres = Unit<std::ratio<1>, 1, std::ratio<1>, 0, std::ratio<1>, 0>;
using Kilometres = Unit<std::kilo, 1, std::ratio<1>, 0, std::ratio<1>, 0>; // std::kilo is an alias for std::ratio<1000, 1>
using Kilograms = Unit<std::ratio<1>, 0, std::ratio<1>, 1, std::ratio<1>, 0>;

---

